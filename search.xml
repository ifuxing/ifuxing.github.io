<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>测试密码</title>
    <url>/2018/12/13/%E5%AF%86%E7%A0%81%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>不论什么时候，心里要有爱，眼里要有光</p>
<a id="more"></a>
<p>这里更多的内容</p>
<p>这里是18年，我刚入职不久，我希望能成为一个有价值的人</p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>简述Spring Boot原理分析_</title>
    <url>/2019/02/13/%E7%AE%80%E8%BF%B0SpringBoot%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_/</url>
    <content><![CDATA[<p>​        Spring Boot基于Spring4.0设计的，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外Spring Boot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。以下纯属个人简单的了解，并没有列出源码深入叙述，是为了帮助自己更好的理解Spring Boot。</p>
<a id="more"></a>

<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><h3 id="Conditional注解"><a href="#Conditional注解" class="headerlink" title="@Conditional注解"></a>@Conditional注解</h3><ul>
<li><p>@Condition是Spring4.0后引入的条件化配置接口，通过实现Condition接口可以完成有条件的加载相应的Bean</p>
</li>
<li><p>@Conditional要配和Condition的实现类（ClassCondition）进行使用</p>
<ul>
<li><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><ol>
<li><p>加上@Conditionl注解后会对这个已经注入到Spring的IOC容器中Bean进行判断，该注解有很多实现类，是根据各种不同的情况来判断，大多通过获取注解中的字节码文件来进行判断，可以根据所有的方法名来了解该功能</p>
</li>
<li><p>是根据Condition接口中的matches方法的返回值进行判断，该方法有两个参数对象，ConditionContext context和AnnotatedTypeMetadata metadata</p>
<ul>
<li>context：上下文对象，用来获取环境，IOC容器和ClassLoader对象</li>
<li>metadata：注解元对象，用来获取注解定义的属性值，通过getAnnotationAttributes方法获取</li>
</ul>
</li>
<li><p>true则将Spring IOC容器中的Bean进行加载，否则不加载</p>
</li>
<li><p>常用条件注解</p>
<p><img src="/images/loading.png" data-original="https://cdn.jsdelivr.net/gh/self-disciplined/pic_star@main/notes-pic/20201103210940.png" alt="image-20201103210939890"></p>
</li>
<li><p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfig</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="comment">//字节码存在则加载下面的Bean</span></span><br><span class="line">      <span class="meta">@ConditionOnClass(&quot;com.alibaba.fastjson.JSON&quot;)</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="meta">@ConditionalOnProperty(name = &quot;itcast&quot;,havingValue = &quot;itheima&quot;)</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> User <span class="title">user2</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="切换内置服务器"><a href="#切换内置服务器" class="headerlink" title="切换内置服务器"></a>切换内置服务器</h3><ul>
<li><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><ol>
<li>在pom文件中将starter-web的依赖中排除starter-tomcat的依赖</li>
<li>加入starter-jetty的依赖即可</li>
</ol>
</li>
<li><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ul>
<li>同样是根据@Condition注解的原理判断是否存在相关以来的类的字节码名称，存在才会加载Spring的IOC容器中的相关的bean</li>
</ul>
</li>
</ul>
<h3 id="Enable-的相关注解"><a href="#Enable-的相关注解" class="headerlink" title="@Enable* 的相关注解"></a>@Enable* 的相关注解</h3><ul>
<li>用于动态开启某种功能（就是获取相关类及其所含方法），==底层原理的就是使用@import注解导入一些配置类，实现Bean的动态加载==</li>
<li>==注意：==Spring Boot工程不能直接获取jar包中定义的Bean<ul>
<li>原因：@ComponentScan的扫描范围是当前引导类所在的包及其子包</li>
<li>解决：<ol>
<li>使用@ComponentScan扫描com.itheima.config（配置类）</li>
<li>可使用@import注解来加载类，使这些类都会被Spring创建，并注入IOC容器</li>
<li>将上述的@import注解进行封装并使用</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h3><ul>
<li><p>@Enable*底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中。而@Import提供4中用法：</p>
<ol>
<li><p><strong>导入Bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(User.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ConfigurableApplicationContext context = SpringApplication.run(Spring BootEnableApplication.class, args);</span><br><span class="line">  	</span><br><span class="line">      <span class="comment">//直接导入Bean创建出来的名字不一定与导入的相同，需要用这个方法查看一下</span></span><br><span class="line">      User user = context.getBean(User.class); </span><br><span class="line">      System.out.println(user);</span><br><span class="line">  </span><br><span class="line">      Role role = context.getBean(Role.class);</span><br><span class="line">      System.out.println(role);</span><br><span class="line">      Map&lt;String, User  map = context.getBeansOfType(User.class);</span><br><span class="line">      System.out.println(map);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>导入配置类</strong></p>
<p><img src="/images/loading.png" data-original="https://cdn.jsdelivr.net/gh/ifuxing/pic_star@main/notes-pic/20201107145805.png" alt="image-20201107145805680"></p>
</li>
<li><p><strong>导入 ImportSelector 实现类。一般用于加载配置文件中的类</strong></p>
<p><img src="/images/loading.png" data-original="https://cdn.jsdelivr.net/gh/ifuxing/pic_star@main/notes-pic/20201107151352.png" alt="image-20201107151352162"></p>
</li>
<li><p><strong>导入 ImportBeanDefinitionRegistrar 实现类。</strong></p>
<p><img src="/images/loading.png" data-original="https://cdn.jsdelivr.net/gh/ifuxing/pic_star@main/notes-pic/20201107154713.png" alt="image-20201107154713551"></p>
</li>
</ol>
</li>
</ul>
<p>​    </p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><ul>
<li><strong>介绍</strong><ol>
<li>@EnableAutoConfiguration 注解内部使用@Import(AutoConfigurationImportSelector.class)来加载配置类。 </li>
<li> 配置文件位置：META-INF/spring.factories，该配置文件中定义了大量的配置类，当 Spring Boot 应用启动时，会自动加载这些配置类，初始化Bean</li>
<li>==注意：==并不是所有的Bean都会被初始化，在配置类中使用Condition来加载满足条件的Bean</li>
</ol>
</li>
</ul>
<h3 id="自定义starter步骤分析"><a href="#自定义starter步骤分析" class="headerlink" title="自定义starter步骤分析"></a>自定义starter步骤分析</h3><ul>
<li><p><strong>需求：</strong></p>
</li>
<li><p>自定义redis-starter，要求当导入redis坐标时，Spring Boot自动创建Jedis的Bean。</p>
<ul>
<li><strong>步骤：</strong></li>
</ul>
</li>
</ul>
<ol>
<li>创建 redis-spring-boot-autoconfigure 模块<ol start="2">
<li>创建 redis-spring-boot-starter 模块,依赖 redis-spring-boot-autoconfigure的模块</li>
<li>在 redis-spring-boot-autoconfigure 模块中初始化 Jedis 的 Bean。并定义META-INF/spring.factories 文件</li>
<li>在测试模块中引入自定义的 redis-starter 依赖，测试获取 Jedis 的Bean，操作 redis。</li>
</ol>
</li>
</ol>
<hr>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><ul>
<li><p><strong>简介</strong></p>
<ul>
<li>Java中的事件监听机制定义了以下几个角色：</li>
<li><ol>
<li>事件：Event，继承 java.util.EventObject 类的对象</li>
<li>事件源：Source ，任意对象Object</li>
<li>监听器：Listener，实现 java.util.EventListener 接口 的对象</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>Spring Boot 在项目启动时，会对几个监听器进行回调</strong></p>
<ul>
<li>==其中==：<ul>
<li>MyApplicationRunner和MyCommandLineRunner都是当项目启动后执行，使用@Component放入容器即可使用</li>
<li>MyApplicationContextInitializer和SpringApplicationRunListener的使用时,要在resource文件夹下添加META-INF/spring.factories,在配置文件中加入配置</li>
</ul>
</li>
</ul>
<ol>
<li><p>ApplicationRunner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当项目启动后执行run方法。</span></span><br><span class="line"><span class="comment"> * 可以在项目启动时，自动调用run方法，比如需要在项目开启时加入数据库缓存，（缓存预热）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationRunner...run&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.asList(args.getSourceArgs()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>CommandLineRunner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CommandLineRunner...run&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.asList(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ApplicationContextInitializer</p>
<p><img src="/images/loading.png" data-original="https://cdn.jsdelivr.net/gh/ifuxing/pic_star@main/notes-pic/20201107211340.png" alt="image-20201107211340369"></p>
</li>
<li><p>SpringApplicationRunListener</p>
</li>
</ol>
<p><img src="/images/loading.png" data-original="https://cdn.jsdelivr.net/gh/ifuxing/pic_star@main/notes-pic/20201107212127.png" alt="image-20201107212127309"></p>
</li>
</ul>
<h2 id="启动流程图"><a href="#启动流程图" class="headerlink" title="启动流程图"></a>启动流程图</h2><p><img src="/images/loading.png" data-original="https://cdn.jsdelivr.net/gh/ifuxing/pic_star@main/notes-pic/20201107222428.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
</search>
